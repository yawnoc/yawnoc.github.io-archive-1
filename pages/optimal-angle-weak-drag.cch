<*>
  Projectile motion: optimal launch angle for weak quadratic drag
  | 20190621 | 20190918 | dm
</*>

<=h>
  <@ih></@ih>
  <@it></@it>
  <@i> Solution | #solution | </@i>
  <@ir></@ir>
  <@i> Numerics | #numerics | Numerical verification </@i>
  <@ic></@ic>
</=h>

<h1>Projectile motion: optimal launch angle for weak quadratic drag</h1>

<*p>
  <@>
    Projectile motion: optimal launch angle from a platform
    | /pages/optimal-angle-platform.html
    |
  </@>
</*p>

<p>
  In the absence of air resistance, a launch angle of 45° maximises range.
  When there is drag linear in speed, the equations of motion can be integrated
  analytically, and closed-form expressions in terms of the
  <@>
    Lambert <$>W</$> function
    | http://mathworld.wolfram.com/LambertW-Function.html
    | Lambert W-Function
  </@>
  can be obtained for the optimal launch angle; see
  <@>
    Packel \&~Yuen (2004)
    | https://www.researchgate.net/publication/228851314_Projectile_Motion_with_Resistance_and_the_Lambert_W_Function
    | Projectile Motion with Resistance and the Lambert W Function
  </@>.
  However, a more realistic model of air resistance
  has drag proportional to the <strong>square</strong> of speed,
  for which the equations of motion are nonlinear and
  analytic solutions cannot be obtained.
</p>

<p>
  In high school there was this rather horrible investigation where
  we had to (experimentally) compare the optimal launch angle of
  a golf ball and a ping-pong ball.
  At the time I believed that nothing much could be done in terms of modelling
  other than solving the equations of motion numerically,
  but back then I knew nothing of scaling and perturbation theory.
  Now armed with some basic knowledge of these very useful tools,
  I have been able to derive an expansion for the optimal launch angle
  when air resistance is relatively weak.
</p>

<$d>
  \gdef\po#1{\color{grey} {} + O \!\left( #1 \right)}
</$d>

<-->
  <-t></-t>
  <-m></-m>
  line, polyline {
    stroke:        black;
    vector-effect: non-scaling-stroke;
  }
  polyline {
    fill: none;
  }
  polyline.points {
    fill:   none;
    stroke: none;
  }
</-->


<@2> Solution | solution </@2>


<p>
  <b>Manuscript:</b>
  <@>
    <`>resistance.pdf</`>~(983~KB)
    | /manuscripts/resistance.pdf
    | Manuscript for Projectile motion: optimal launch angle for weak quadratic drag
  </@>
</p>

<!--                      Trajectory diagram
  ***********************************************************************
  Constant    Description                           Value
  ***********************************************************************
    r           range                                  10
    m           slope of velocity vector                2
    wu          width of velocity vector                1
    hu          height of velocity vector               2
    xleft       left x pos                            - 2
    xright      right x pos                            12
    w           total width                            14
    ytop        top y pos                             - 9
    ybottom     bottom y pos                            1
    h           total height                           10
  ***********************************************************************
  -->
<div class="centred-svg">
<svg class="fit-width" width="360px" viewBox="-2 -9 14 10">
  <!-- Marker definitions -->
  <defs>
    <!-- velocity arrowhead -->
    <marker
      id = "arrowhead"
      viewBox = "0 -0.3 1 0.6"
      refX = "1"
      refY = "0"
      markerWidth = "1"
      markerHeight = "0.3"
      orient = "auto-start-reverse">
      <path d="M 0, -0.3 L 0, 0.3 L 1, 0 z" />
    </marker>
  </defs>
  <!-- x-axis -->
  <line
    x1 = "0"
    y1 = "0"
    x2 = "11"
    y2 = "0" />
  <text class="m"
    x = "11"
    y = "0"
    font-size = "0.8"
    dx = "0.6em"
    dy = "0.3em"
    >x
  </text>
  <!-- y-axis -->
  <line
    x1 = "0"
    y1 = "0"
    x2 = "0"
    y2 = "-8" />
  <text class="m"
    x = "0"
    y = "-8"
    font-size = "0.8"
    dy = "-0.5em"
    >y
  </text>
  <!-- trajectory -->
  <!--
b_big  = 3;
phi_pd = atand (2);
[~, z_sol, r_big] = trajectory (b_big, phi_pd);
x_sol = z_sol(:, 3);
y_sol = z_sol(:, 4);
## Scale to order 10 and negate y coordinates for SVG
len   = 0.1 * r_big;
x_sol =  x_sol / len;
y_sol = -y_sol / len;
csvwrite ("trajectory-plot.csv", [x_sol, y_sol]);
    -->
  <polyline
    points="0,-0
  0.245110995009268,-0.4861517187099219
  0.4801816778208002,-0.9442990762404092
  0.7061283410059535,-1.376564718270853
  0.9237540146997104,-1.784803909709473
  1.133766485868184,-2.17064684000858
  1.336792869363945,-2.535532833557729
  1.533391492313122,-2.880738253952923
  1.724061663894877,-3.20739944609674
  1.909251765092096,-3.516531737366786
  2.089365991982065,-3.809045282034206
  2.264770011055041,-4.085758356967491
  2.435795728634328,-4.347408584369548
  2.602745333652655,-4.594662456963978
  2.76589474023019,-4.828123464253595
  2.925496531134009,-5.048339059200991
  3.081782483421603,-5.255806658574985
  3.234965742026746,-5.450978834089852
  3.38524269473549,-5.634267822993407
  3.532794592180965,-5.806049464193965
  3.677788948603188,-5.966666648049691
  3.820380752758038,-6.116432353591867
  3.960713513205941,-6.255632335466698
  4.098920158033827,-6.384527513683672
  4.235123805694466,-6.503356111905964
  4.369438420967384,-6.612335584157149
  4.501969367979156,-6.711664365160388
  4.632813870727246,-6.801523475823584
  4.762061390617189,-6.882078012407363
  4.889793930152557,-6.953478545430908
  5.016086272118472,-7.015862452134082
  5.141006164361472,-7.069355204043503
  5.264614461531801,-7.114071628578432
  5.386965236775468,-7.150117160367124
  5.508105878083932,-7.17758909375813
  5.628077185443655,-7.196577842761952
  5.746913485592883,-7.207168208426642
  5.864642780596629,-7.209440646820895
  5.981286944232264,-7.203472524073881
  6.096861976266584,-7.189339339232466
  6.211378319423947,-7.167115891986404
  6.324841237895225,-7.136877371261181
  6.437251250535266,-7.098700342475037
  6.548604607319247,-7.052663615519793
  6.658893794768655,-6.998848981418945
  6.768108055095087,-6.937341812106284
  6.876233904530815,-6.868231523899972
  6.983255638249318,-6.791611910344956
  7.089155811874273,-6.70758135383282
  7.1939156923393,-6.616242927759631
  7.297515673437696,-6.517704402129121
  7.399935653588117,-6.412078165726036
  7.501155375062937,-6.299481077559179
  7.601154725192267,-6.180034259454105
  7.699914000927657,-6.05386284065242
  7.797414138703765,-5.921095664180707
  7.89363691185142,-5.78186496367088
  7.988565097959823,-5.636306018292383
  8.082182618613752,-5.484556792517172
  8.174474653884809,-5.326757566587363
  8.265427733863735,-5.163050562790394
  8.355029809403963,-4.993579571960725
  8.443270304118396,-4.81848958401205
  8.530140149540232,-4.637926425751409
  8.61563180522962,-4.452036408728777
  8.699739265483609,-4.26096598942619
  8.782458054188535,-4.06486144368398
  8.863785209242026,-3.863868556893695
  8.943719257866137,-3.658132331154653
  9.022260184033234,-3.447796710290666
  9.099409389131933,-3.233004323353309
  9.175169646910954,-3.013896246996092
  9.249545053654039,-2.790611786888482
  9.322540974458599,-2.563288278148248
  9.394163986414355,-2.33206090460384
  9.464421819405738,-2.097062536553843
  9.533323295193004,-1.858423586566768
  9.600878265361974,-1.61627188276009
  9.667097548670762,-1.370732558911131
  9.731992868263907,-1.121927960682738
  9.79557678916998,-0.8699775671923655
  9.857862656447724,-0.6149979271126464
  9.918864534298352,-0.3571026084636498
  9.978597146417505,-0.09640216124025217
  9.999999999999998,-1.12021820651121e-015
  "
  />
  <!-- launch angle phi -->
  <text class="m"
    x = "1.2"
    y = "-0.1"
    font-size = "0.8"
    dx = "-0.5em"
    dy = "-0.35em"
    >ϕ
  </text>
  <!-- range R -->
  <text class="m"
    x = "10"
    y = "0"
    font-size = "0.8"
    dy = "1em"
    >R
  </text>
  <!-- velocity vector u -->
  <line
    x1 = "0"
    y1 = "0"
    x2 = "1"
    y2 = "-2"
    marker-end = "url(#arrowhead)" />
  <text class="m"
    x = "1"
    y = "-2"
    font-size = "0.8"
    dx = "-0.6em"
    >u
  </text>
</svg>
</div>

<@3> Equations of motion | motion </@3>

<p>
  Suppose a projectile of mass <$>m</$> is launched at
  speed <$>u</$> and angle <$>\phi</$> from the ground,
  which has gravitational field strength <$>g</$>,
  and let there be drag proportional to the square of the projectile's speed,
  with constant of proportionality <$>b</$>.
  Let dots denote time derivatives.
  The drag force on the projectile has magnitude
  <$>b \| \dot{\vec{x}} \|^2</$>, and it acts
  in the direction opposite to the projectile's velocity,
  i.e.~in the direction <$>-\dot{\vec{x}} / \| \dot{\vec{x}} \|</$>.
  Therefore the drag force is <$>-b \dot{\vec{x}} \| \dot{\vec{x}} \|</$>,
  and so in components the equations of motion are
</p>

<$$>
  \begin{alignedat}{4}
    m \ddot{x} &=      && - b \dot{x} \sqrt{\dot{x}^2 + \dot{y}^2},
      \quad & \dot{x} (0) &= u \cos\phi, \quad & x (0) &= 0, \\
    m \ddot{y} &= -m g && - b \dot{y} \sqrt{\dot{x}^2 + \dot{y}^2},
      \quad & \dot{y} (0) &= u \sin\phi, \quad & y (0) &= 0.
  \end{alignedat}
</$$>

<@3> Scaling | scaling </@3>

<p>
  Since we shall be making a perturbation from the dragless <$>b = 0</$> case,
  it is appropriate to choose the length scale and time scale thereof.
  In the dragless case the mass <$>m</$> is irrelevant,
  and the only parameters are the initial speed <$>u</$>
  and gravitational acceleration <$>g</$>, yielding the length scale
</p>
<$$>
  L = u^2 / g
</$$>
<p>
  and the time scale
</p>
<$$>
  T = u / g.
</$$>

<p>
  Therefore we put <$>\hat{x} = x / L</$>,
  <$>\hat{y} = y / L</$> and <$>\hat{t} = t / T</$> to obtain
  scaled (dimensionless) variables <$>\hat{x}</$>,
  <$>\hat{y}</$> and <$>\hat{t}</$>.
  Dropping the hats, the equations of motion become
</p>
<$$>
  \begin{alignedat}{4}
    \ddot{x} &=    && - B \dot{x} \sqrt{\dot{x}^2 + \dot{y}^2},
      \quad & \dot{x} (0) &= \cos\phi, \quad & x (0) &= 0, \\
    \ddot{y} &= -1 && - B \dot{y} \sqrt{\dot{x}^2 + \dot{y}^2},
      \quad & \dot{y} (0) &= \sin\phi, \quad & y (0) &= 0,
  \end{alignedat}
</$$>
<p>where</p>
<$$>
  B = \frac{b u^2}{m g}
</$$>
<p>
  is the initial drag-to-weight ratio,
  the only dimensionless group in the problem.
  By definition, the projectile's terminal speed <$>c</$> is given by
</p>
<$$>
  1 = \frac{b c^2}{m g}.
</$$>
<p>
  Dividing these, we see that
</p>
<$$>
  B = \left( \frac{u}{c} \right)^2.
</$$>

<p>
  Now the optimal angle is dimensionless, so it can depend only on
  the sole dimensionless group <$>B</$>.
  Thus, <strong>the optimal angle depends only on <$>\sqrt{B} = u / c</$>,
  the ratio between the initial and terminal speeds</strong>.
  (I wish I knew this back in Year~12.)
</p>

<@3> Perturbed trajectory | perturbation </@3>

<p>
  By "weak drag" I mean that <$>B \ll 1</$>, i.e.~<$>u^2 \ll c^2</$>.
  We make an asymptotic expansion in powers of <$>B</$> about <$>B = 0</$>:
</p>
<$$>
  \begin{aligned}
    \dot{x} &= \dot{x}_0 + B \dot{x}_1 + B^2 \dot{x}_2 \po{B^3} \\
    \dot{y} &= \dot{y}_0 + B \dot{y}_1 + B^2 \dot{y}_2 \po{B^3}
  \end{aligned}
</$$>

<p>
  Substituting these into the equations of motion and doing some algebra,
  we obtain
</p>
<$$>
  \begin{alignedat}{2}
    \ddot{x}_0 + B \ddot{x}_1 + B^2 \ddot{x}_2 &=
      && - B \big[ \dot{x}_0 v_0 \big]
      - B^2 \left[ \dot{x}_1 v_0 + \frac{\dot{x}_0 w_1}{v_0} \right]
      \po{B^3}, \\
    \ddot{y}_0 + B \ddot{y}_1 + B^2 \ddot{y}_2 &=
      - 1
      && - B \big[ \dot{y}_0 v_0 \big]
      - B^2 \left[ \dot{y}_1 v_0 + \frac{\dot{y}_0 w_1}{v_0} \right]
      \po{B^3},
  \end{alignedat}
</$$>
<p>where</p>
<$$>
  \begin{aligned}
    v_0 &= \sqrt{{\dot{x}_0}^2 + {\dot{y}_0}^2}, \\
    w_1 &= \dot{x}_0 \dot{x}_1 + \dot{y}_0 \dot{y}_1.
  \end{aligned}
</$$>
<p>
  Equating coefficients of <$>B</$>, we obtain
</p>
<$$>
  \begin{alignedat}{4}
    \ddot{x}_0 &= {} &  0 &,
      \quad & \dot{x}_0 (0) &= \cos\phi, \quad & x_0 (0) &= 0, \\
    \ddot{y}_0 &= {} & -1 &,
      \quad & \dot{y}_0 (0) &= \sin\phi, \quad & y_0 (0) &= 0,
  \end{alignedat}
</$$>
<$$>
  \begin{alignedat}{3}
    \ddot{x}_1 &= -\dot{x}_0 v_0,
      \quad & \dot{x}_1 (0) &= 0, \quad & x_1 (0) &= 0, \\
    \ddot{y}_1 &= -\dot{y}_0 v_0,
      \quad & \dot{y}_1 (0) &= 0, \quad & y_1 (0) &= 0,
  \end{alignedat}
</$$>
<$$>
  \begin{alignedat}{3}
    \ddot{x}_2 &= -\left[ \dot{x}_1 v_0 + \frac{\dot{x}_0 w_1}{v_0} \right],
      \quad & \dot{x}_2 (0) &= 0, \quad & x_2 (0) &= 0, \\
    \ddot{y}_2 &= -\left[ \dot{y}_1 v_0 + \frac{\dot{y}_0 w_1}{v_0} \right],
      \quad & \dot{y}_2 (0) &= 0, \quad & y_2 (0) &= 0,
  \end{alignedat}
</$$>
<$$>
  \text{etc.}
</$$>

<p>
  Thus <$>\dot{x}_0, x_0, \dot{y}_0, y_0, \dot{x}_1,
  \text{etc.}</$> can be determined by straight integration,
  although the expressions become very complicated (see
  <@>
    manuscript
    | /manuscripts/resistance.pdf
    | Manuscript for Projectile motion: optimal launch angle for weak quadratic drag
  </@>
  for details).
  For brevity, we define the following:
</p>
<$$>
  \begin{aligned}
    \alpha &= \cos\phi \\
     \beta &= \sin\phi \\
      \tau &= t - \beta \\
         r &= \frac{\tau + v_0}{-\beta + 1}
  \end{aligned}
</$$>
<p>
  Note that <$>v_0 = \sqrt{\alpha^2 + \tau^2}</$>.
  After a lot of algebra and integration, we obtain:
</p>
<$$>
  \begin{aligned}
    \ddot{x}_0 &= 0 \\[0.2em]
     \dot{x}_0 &= \alpha \\[0.2em]
           x_0 &= \alpha t
  \end{aligned}
</$$>
<$$>
  \begin{aligned}
    \ddot{y}_0 &= -1 \\[0.2em]
     \dot{y}_0 &= -\tau \\[0.2em]
           y_0 &= -\tfrac{1}{2} \tau^2 + \tfrac{1}{2} \beta^2
  \end{aligned}
</$$>
<$$>
  \begin{aligned}
    \ddot{x}_1 &= -\alpha v_0 \\[0.2em]
     \dot{x}_1 &=
      - \Big[ \tfrac{1}{2} \alpha \beta \Big]
      - \Big[ \tfrac{1}{2} \alpha \Big] \tau v_0
      - \Big[ \tfrac{1}{2} \alpha^3 \Big] \log r
      \\[0.4em]
    x_1 &=
      - \Big[ \tfrac{1}{3} \alpha \Big]
      - \Big[ \tfrac{1}{2} \alpha \beta \Big] \tau
      + \Big[ \tfrac{1}{2} \alpha^3 \Big] v_0
      - \Big[ \tfrac{1}{6} \alpha \Big] {v_0}^3
      - \Big[ \tfrac{1}{2} \alpha^3 \Big] \tau \log r
  \end{aligned}
</$$>
<$$>
  \begin{aligned}
    \ddot{y}_1 &= \tau v_0 \\[0.2em]
     \dot{y}_1 &= \tfrac{1}{3} {v_0}^3 - \tfrac{1}{3} \\[0.4em]
           y_1 &=
        \Big[ {-\tfrac{1}{4}} + \tfrac{1}{8} \alpha^2 \Big] \beta
      - \Big[ \tfrac{1}{3} \Big] \tau
      + \Big[ \tfrac{1}{8} \alpha^2 \Big] \tau v_0
      + \Big[ \tfrac{1}{12} \Big] \tau {v_0}^3
      + \Big[ \tfrac{1}{8} \alpha^4 \Big] \log r
  \end{aligned}
</$$>
<$$>
  \begin{aligned}
    \ddot{x}_2 &=
        \Big[ \tfrac{4}{3} \alpha^3 \Big] \tau
      + \Big[ \tfrac{5}{6} \alpha \Big] \tau^3
      + \Big[ \tfrac{1}{2} \alpha^3 \beta \Big] \frac{1}{v_0}
      - \Big[ \tfrac{1}{3} \alpha \Big] \frac{\tau}{v_0}
      + \Big[ \tfrac{1}{2} \alpha \beta \Big] v_0
      + \Big[ \tfrac{1}{2} \alpha^5 \Big] \frac{\log r}{v_0} \\ & \quad
      + \Big[ \tfrac{1}{2} \alpha^3 \Big] v_0 \log r
      \\[0.4em]
    \dot{x}_2 &=
        \Big[
          \tfrac{3}{8} \alpha - \tfrac{3}{8} \alpha^3 + \tfrac{1}{3} \alpha^5
        \Big]
      + \Big[ \tfrac{13}{24} \alpha^3 \Big] \tau^2
      + \Big[ \tfrac{5}{24} \alpha \Big] \tau^4
      - \Big[ \tfrac{1}{3} \alpha \Big] v_0
      + \Big[ \tfrac{1}{4} \alpha \beta \Big] \tau v_0 \\ & \quad
      + \Big[ \tfrac{3}{4} \alpha^3 \beta \Big] \log r
      + \Big[ \tfrac{1}{4} \alpha^3 \Big] \tau v_0 \log r
      + \Big[ \tfrac{3}{8} \alpha^5 \Big] \log^2 r
      \\[0.4em]
    x_2 &=
        \Big[
          \tfrac{1}{6} \alpha + \tfrac{4}{9} \alpha^3 + \tfrac{8}{9} \alpha^5
        \Big] \beta
      + \Big[
          \tfrac{3}{8} \alpha - \tfrac{3}{8} \alpha^3 + \alpha^5
        \Big] \tau
      + \Big[ \tfrac{11}{72} \alpha^3 \Big] \tau^3
      + \Big[ \tfrac{1}{24} \alpha \Big] \tau^5 \\ & \quad
      - \Big[ \tfrac{3}{4} \alpha^3 \beta \Big] v_0
      - \Big[ \tfrac{1}{6} \alpha \Big] \tau v_0
      + \Big[ \tfrac{1}{12} \alpha \beta \Big] {v_0}^3
      - \Big[ \tfrac{1}{6} \alpha^3 \Big] \log r
      + \Big[ \tfrac{3}{4} \alpha^3 \beta \Big] \tau \log r \\ & \quad
      - \Big[ \tfrac{3}{4} \alpha^5 \Big] v_0 \log r
      + \Big[ \tfrac{1}{12} \alpha^3 \Big] {v_0}^3 \log r
      + \Big[ \tfrac{3}{8} \alpha^5 \Big] \tau \log^2 r
  \end{aligned}
</$$>
<$$>
  \begin{aligned}
    \ddot{y}_2 &=
      - \Big[ \tfrac{1}{3} \alpha^4 \Big]
      - \Big[ \tfrac{3}{2} \alpha^2 \Big] \tau^2
      - \Big[ \tfrac{2}{3} \Big] \tau^4
      + \Big[ \tfrac{1}{3} \Big] v_0
      - \Big[ \tfrac{1}{2} \alpha^2 \beta \Big] \frac{\tau}{v_0}
      + \Big[ \tfrac{1}{3} \Big] \frac{\tau^2}{v_0}
      - \Big[ \tfrac{1}{2} \alpha^4 \Big] \frac{\tau \log r}{v_0}
      \\[0.4em]
    \dot{y}_2 &=
        \Big[
          \tfrac{1}{5} + \tfrac{4}{15} \alpha^2 + \tfrac{8}{15} \alpha^4
        \Big] \beta
      + \Big[ \tfrac{1}{6} \alpha^4 \Big] \tau
      - \Big[ \tfrac{1}{2} \alpha^2 \Big] \tau^3
      - \Big[ \tfrac{2}{15} \Big] \tau^5
      - \Big[ \tfrac{1}{2} \alpha^2 \beta \Big] v_0
      + \Big[ \tfrac{1}{3} \Big] \tau v_0 \\ & \quad
      - \Big[ \tfrac{1}{2} \alpha^4 \Big] v_0 \log r
      \\[0.4em]
    y_2 &=
        \Big[
          \tfrac{1}{9} - \tfrac{1}{8} \alpha^2 + \tfrac{1}{8} \alpha^4
        - \tfrac{2}{9} \alpha^6
        \Big]
      + \Big[
          \tfrac{1}{5} + \tfrac{4}{15} \alpha^2 + \tfrac{8}{15} \alpha^4
        \Big] \beta \tau
      + \Big[ \tfrac{5}{24} \alpha^4 \Big] \tau^2
      - \Big[ \tfrac{1}{8} \alpha^2 \Big] \tau^4 \\ & \quad
      - \Big[ \tfrac{1}{45} \Big] \tau^6
      - \Big[ \tfrac{1}{4} \alpha^2 \beta \Big] \tau v_0
      + \Big[ \tfrac{1}{9} \Big] {v_0}^3
      - \Big[ \tfrac{1}{4} \alpha^4 \beta \Big] \log r
      - \Big[ \tfrac{1}{4} \alpha^4 \Big] \tau v_0 \log r \\ & \quad
      - \Big[ \tfrac{1}{8} \alpha^6 \Big] \log^2 r
  \end{aligned}
</$$>
<p>
  You might be wondering why I stopped at order <$>B^2</$>.
  Initially I thought that integration could be performed to arbitrary order
  (although the amount of algebra required grows {very} quickly).
  However I was wrong; it turns out that the following integrals
  appear at cubic order, which have no closed-form expression:
</p>
<$$>
  \begin{aligned}
    &
    \int
      \frac{
        \tau \log \big( \tau + \sqrt{\alpha^2 + \tau^2} \big)
      }{
        \alpha^2 + \tau^2
      }
    \td\tau \\[0.4em]
    &
    \int
      \frac{
        \log^2 \big( \tau + \sqrt{\alpha^2 + \tau^2} \big)
      }{
        (\alpha^2 + \tau^2)^{3/2}
      }
    \td\tau
  \end{aligned}
</$$>
<p>
  If you are able to evaluate either of the two integrals above,
  please contact me at <`>leeconway@protonmail.com</`>.
  On the other hand, quartic terms, even if they could be found,
  would be of little practical use, since the expansion is asymptotic
  and as such probably does not converge.
</p>

<@3> Flight time | time </@3>

<p>
  Having determined the trajectory, we then determine the flight time,
  given by <$>y (t) = 0</$>.
  To quadratic order, i.e.~with
  <$>y = y_0 + B y_1 + B^2 y_2 \po{B^3}</$> and
  <$>t = t_0 + B t_1 + B^2 t_2 \po{B^3}</$>, this becomes
</p>
<$$>
  \begin{aligned}
    y_0 (t_0)
    & + B \big[ t_1 \dot{y}_0 (t_0) + y_1 (t_0) \big] \\
    & + B^2
      \Big[
        t_2 \dot{y}_0 (t_0)
      + \tfrac{1}{2} {t_1}^2 \ddot{y}_0 (t_0)
      + t_1 \dot{y}_1 (t_0)
      + y_2 (t_0)
      \Big] \po{B^3} = 0.
  \end{aligned}
</$$>
<p>
  The unperturbed (dragless) flight time is given by the positive solution to
  <$>y_0 (t_0) = 0</$>, which is
</p>
<$$>
  t_0 = 2 \beta.
</$$>
<p>
  From the linear and quadratic terms we obtain
</p>
<$$>
  \begin{aligned}
    t_1 &= y_1 (t_0) \big/ {-\dot{y}_0 (t_0)}, \\[0.2em]
    t_2 &=
      \Big[
        \tfrac{1}{2} {t_1}^2 \ddot{y}_0 (t_0)
      + t_1 \dot{y}_1 (t_0)
      + y_2 (t_0)
      \Big] \Big/ {-\dot{y}_0 (t_0)},
  \end{aligned}
</$$>
<p>
  which, after some more algebra, reduce to
</p>
<$$>
  \begin{aligned}
    t_1 &=
      \Big[ {-\tfrac{1}{2}} + \tfrac{\alpha^2}{4} \Big]
    + \Big[ \tfrac{1}{8} \alpha^4 \Big] \frac{\log\rho}{\beta}, \\[0.4em]
    t_2 &=
      \Big[
        \tfrac{11}{40}
      - \tfrac{29}{120} \alpha^2
      + \tfrac{481}{480} \alpha^4
      - \tfrac{16}{15} \alpha^6
      \Big] \frac{1}{\beta}
    + \Big[
        {-\tfrac{7}{16} \alpha^4}
      + \tfrac{15}{32} \alpha^6
      \Big] \frac{\log\rho}{\beta^2} \\ & \quad
    + \Big[
        {-\tfrac{1}{8} \alpha^6}
      + \tfrac{15}{128} \alpha^8
      \Big] \frac{\log^2\rho}{\beta^3},
  \end{aligned}
</$$>
<p>where</p>
<$$>
  \rho = \frac{1 + \beta}{1 - \beta}.
</$$>

<p>
  By now, <$>t_0, t_1, t_2</$> are just functions of <$>\phi</$>
  (remember <$>\alpha</$> and <$>\beta</$> are abbreviations
  for <$>\cos\phi</$> and <$>\sin\phi</$>).
</p>

<@3> Range | range </@3>

<p>
  To quadratic order, the range is
</p>
<$$>
  \begin{aligned}
    R
    &= x (t) \\
    &=
    x_0 (t_0)
    + B \big[ t_1 \dot{x}_0 (t_0) + x_1 (t_0) \big]
    + B^2
      \Big[
        t_2 \dot{x}_0 (t_0)
      + t_1 \dot{x}_1 (t_0)
      + x_2 (t_0)
      \Big] \po{B^3} \\
    &= R_0 + B R_1 + B^2 R_2 \po{B^3},
  \end{aligned}
</$$>
<p>
  where, after some more algebra,
</p>
<$$>
  \begin{aligned}
    R_0 &= 2 \alpha \beta, \\[0.2em]
    R_1 &=
      \Big[ {-\tfrac{3}{2} \alpha} + \tfrac{5}{4} \alpha^3 \Big]
    + \Big[
        {-\tfrac{1}{2} \alpha^3} + \tfrac{5}{8} \alpha^5
      \Big] \frac{\log\rho}{\beta}, \\[0.4em]
    R_2 &=
      \Big[
        \tfrac{51}{40} \alpha
      - \tfrac{757}{360} \alpha^3
      + \tfrac{5243}{1440} \alpha^5
      - \tfrac{128}{45} \alpha^7
      \Big] \frac{1}{\beta} \\ & \quad
    + \Big[
        \tfrac{11}{12} \alpha^3
      - \tfrac{149}{48} \alpha^5
      + \tfrac{71}{32} \alpha^7
      \Big] \frac{\log\rho}{\beta^2}
    + \Big[
        \tfrac{3}{8} \alpha^5
      - \tfrac{15}{16} \alpha^7
      + \tfrac{71}{128} \alpha^9
      \Big] \frac{\log^2\rho}{\beta^3}.
  \end{aligned}
</$$>

<@3> Optimal launch angle | angle </@3>

<p>
  Let primes denote <$>\phi</$> derivatives.
  Then the optimal launch angle is given by <$>R' (\phi) = 0</$>,
  or, to quadratic order,
</p>
<$$>
  \begin{aligned}
    R'_0 (\phi_0)
    & + B \big[ \phi_1 R''_0 (\phi_0) + R'_1 (\phi_0) \big] \\
    & + B^2
      \Big[
        \phi_2 R''_0 (\phi_0)
      + \tfrac{1}{2} {\phi_1}^2 R'''_0 (\phi_0)
      + \phi_1 R''_1 (\phi_0)
      + R'_2 (\phi_0)
      \Big] \po{B^3} = 0.
  \end{aligned}
</$$>
<p>
  From the constant term, <$>R'_0 (\phi_0) = 2 \cos (2 \phi_0) = 0</$>,
  yielding the familiar
</p>
<$$>
  \phi_0 = \frac{\pi}{4}
</$$>
<p>
  in the absence of air resistance.
  From the linear and quadratic terms we obtain
</p>
<$$>
  \begin{aligned}
    \phi_1 &= R'_1 (\phi_0) \big/ {-R''_0 (\phi_0)}, \\[0.2em]
    \phi_2 &=
      \Big[
        \tfrac{1}{2} {\phi_1}^2 R'''_0 (\phi_0)
      + \phi_1 R''_1 (\phi_0)
      + R'_2 (\phi_0)
      \Big] \Big/ {-R''_0 (\phi_0)},
  \end{aligned}
</$$>
<p>
  which, after a lot of differentiation and yet more algebra, become
</p>
<$$>
  \begin{aligned}
    \phi_1 &= -\tfrac{3}{32} \sqrt{2} + \tfrac{1}{64} p, \\[0.2em]
    \phi_2 &=
      -\tfrac{1393}{3840} + \tfrac{81}{512} p \sqrt{2} + \tfrac{17}{2048} p^2,
  \end{aligned}
</$$>
<p>where</p>
<$$>
  p
  = \log \tfrac{1 + 1 / \sqrt{2}}{1 - 1 / \sqrt{2}}
  = 2 \tanh^{-1} \tfrac{1}{\sqrt{2}}.
</$$>


<@2> Result | result </@2>


<p>
  For small initial drag-to-weight ratios
  (or small initial-to-terminal kinetic energy ratios)
</p>
<$$>
  B = \frac{b u^2}{m g} = \frac{u^2}{c^2} \ll 1,
</$$>
<p>
  the <b>optimal launch angle</b> has the <b>asymptotic expansion</b>
</p>
<$$>
  \boxed{
    \phi = \phi_0 + B \phi_1 + B^2 \phi_2 \po{B^3},
  }
</$$>
<p>where</p>
<$$>
  \begin{aligned}
    \phi_0
      &= \tfrac{\pi}{4} \\
      &= 45 \degree, \\[0.2em]
    \phi_1
      &=
      - \tfrac{3}{32} \sqrt{2}
      + \tfrac{1}{64} \log \tfrac{1 + 1 / \sqrt{2}}{1 - 1 / \sqrt{2}} \\
      &= -6.018 \degree, \\[0.2em]
    \phi_2
      &=
      - \tfrac{1393}{3840}
      + \tfrac{81}{512} \sqrt{2} \log \tfrac{1 + 1 / \sqrt{2}}{1 - 1 / \sqrt{2}}
      + \tfrac{17}{2048} \log^2 \tfrac{1 + 1 / \sqrt{2}}{1 - 1 / \sqrt{2}} \\
      &= 3.290 \degree,
  \end{aligned}
</$$>
<p>that is,</p>
<$$>
  \boxed{
  \begin{aligned}
    \phi
    &= 45 \degree - 6.018 \degree B + 3.290 \degree B^2 \po{B^3} \\
    &= 45 \degree
    - 6.018 \degree \frac{u^2}{c^2}
    + 3.290 \degree \frac{u^4}{c^4} \po{\frac{u^6}{c^6}}.
  \end{aligned}
}
</$$>


<@2> Numerical verification | numerics </@2>


<p>
  In the following table we compare numerically computed optimal launch angles
  (see <@> code below | #code | Code (GNU Octave) </@>)
  with those from the asymptotic <@> result above | #result | Result </@>:
</p>
<!--
optimal_angle_export (
  [ ...
    0 : 0.1 : 1, ...
    2 : 1   : 10, ...
    15, 20, 50, 100, 200, 500, ...
    10 .^ [3, 4, 6, 8]
  ],
  "table"
);
table = csvread ("optimal-angle-table.csv");
table = table(table(:,1) <= 2, :);
table = [table, optimal_angle_asymptotic(table(:,1))];
table = [table, (table(:,3) ./ table(:,2) - 1) * 100];
csvwrite ("optimal-angle-asymptotic-table.csv", table);
  -->
<!c><table>
  <tr>
    <td class="no-border"></td>
    <th colspan="3">Optimal <$>\phi</$></th>
  </tr>
  <tr>
    <th><$>B</$></th>
    <th>Numerical</th>
    <th>Asymptotic</th>
    <th>Rel.~error</th>
  </tr>
  <tr>
    <td>\_\_\_\_0</td>
    <td>45.0°</td>
    <td>45.0°</td>
    <td>\_0</td>
  </tr>
  <tr>
    <td>\_\_\_\_0.1</td>
    <td>44.4°</td>
    <td>44.4°</td>
    <td>\_0.005%</td>
  </tr>
  <tr>
    <td>\_\_\_\_0.2</td>
    <td>43.9°</td>
    <td>43.9°</td>
    <td>\_0.04%</td>
  </tr>
  <tr>
    <td>\_\_\_\_0.3</td>
    <td>43.4°</td>
    <td>43.5°</td>
    <td>\_0.1%</td>
  </tr>
  <tr>
    <td>\_\_\_\_0.4</td>
    <td>43.0°</td>
    <td>43.1°</td>
    <td>\_0.3%</td>
  </tr>
  <tr>
    <td>\_\_\_\_0.5</td>
    <td>42.6°</td>
    <td>42.8°</td>
    <td>\_0.5%</td>
  </tr>
  <tr>
    <td>\_\_\_\_0.6</td>
    <td>42.2°</td>
    <td>42.6°</td>
    <td>\_0.8%</td>
  </tr>
  <tr>
    <td>\_\_\_\_0.7</td>
    <td>41.9°</td>
    <td>42.4°</td>
    <td>\_1.2%</td>
  </tr>
  <tr>
    <td>\_\_\_\_0.8</td>
    <td>41.6°</td>
    <td>42.3°</td>
    <td>\_1.7%</td>
  </tr>
  <tr>
    <td>\_\_\_\_0.9</td>
    <td>41.3°</td>
    <td>42.2°</td>
    <td>\_2.4%</td>
  </tr>
  <tr>
    <td>\_\_\_\_1</td>
    <td>41.0°</td>
    <td>42.3°</td>
    <td>\_3.2%</td>
  </tr>
  <tr>
    <td>\_\_\_\_2</td>
    <td>38.8°</td>
    <td>46.1°</td>
    <td>19%</td>
  </tr>
  <tr>
    <td>\_\_\_\_3</td>
    <td>37.3°</td>
    <td class="not-applicable" rowspan="16" colspan="2"></td>
  </tr>
  <tr>
    <td>\_\_\_\_4</td>
    <td>36.2°</td>
  </tr>
  <tr>
    <td>\_\_\_\_5</td>
    <td>35.3°</td>
  </tr>
  <tr>
    <td>\_\_\_\_6</td>
    <td>34.6°</td>
  </tr>
  <tr>
    <td>\_\_\_\_7</td>
    <td>34.0°</td>
  </tr>
  <tr>
    <td>\_\_\_\_8</td>
    <td>33.5°</td>
  </tr>
  <tr>
    <td>\_\_\_\_9</td>
    <td>33.0°</td>
  </tr>
  <tr>
    <td>\_\_\_10</td>
    <td>32.6°</td>
  </tr>
  <tr>
    <td>\_\_\_15</td>
    <td>31.1°</td>
  </tr>
  <tr>
    <td>\_\_\_20</td>
    <td>30.1°</td>
  </tr>
  <tr>
    <td>\_\_\_50</td>
    <td>27.1°</td>
  </tr>
  <tr>
    <td>\_\_100</td>
    <td>25.2°</td>
  </tr>
  <tr>
    <td>\_\_200</td>
    <td>23.5°</td>
  </tr>
  <tr>
    <td>\_\_500</td>
    <td>22.9°</td>
  </tr>
  <tr>
    <td>\_1000</td>
    <td>19.7°</td>
  </tr>
  <tr>
    <td>10000</td>
    <td>18.1°</td>
  </tr>
</table></!c>

<p>
  Indeed the asymptotic expansion is very accurate for <$>B < 0.5</$>
  (or equivalently <$>u / c < 0.7</$>).
</p>

<!--            Optimal launch angle plot (in terms of B)
  ***********************************************************************
  Constant    Description                           Value
  ***********************************************************************
    xleft       left x pos                            - 2.5
    xright      right x pos                            23
    w           total width                            25.5
    ytop        top y pos                             -48
    ybottom     bottom y pos                          -32
    h           total height                           16
  ***********************************************************************
  Horizontal scale is 4:1.
  -->
<div class="centred-svg">
<svg class="fit-width" width="480px" viewBox="-2.5 -48 25.5 16">
  <!-- Marker definitions -->
  <defs>
    <!-- Horizontal axis coarse tick -->
    <marker
      id = "htickcoarse"
      viewBox = "-0.1 0 0.2 0.4"
      refX = "0"
      refY = "0"
      markerWidth = "0.2"
      markerHeight = "0.4">
      <line
        x1 = "0"
        y1 = "0"
        x2 = "0"
        y2 = "0.4" />
    </marker>
    <!-- Horizontal axis fine tick -->
    <marker
      id = "htickfine"
      viewBox = "-0.1 0 0.2 0.25"
      refX = "0"
      refY = "0"
      markerWidth = "0.2"
      markerHeight = "0.25">
      <line
        x1 = "0"
        y1 = "0"
        x2 = "0"
        y2 = "0.25" />
    </marker>
    <!-- Vertical axis coarse tick -->
    <marker
      id = "vtickcoarse"
      viewBox = "-0.4 -0.1 0.4 0.2"
      refX = "0"
      refY = "0"
      markerWidth = "0.4"
      markerHeight = "0.2">
      <line
        x1 = "-0.4"
        y1 = "0"
        x2 = "0"
        y2 = "0" />
    </marker>
    <!-- Vertical axis fine tick -->
    <marker
      id = "vtickfine"
      viewBox = "-0.25 -0.1 0.25 0.2"
      refX = "0"
      refY = "0"
      markerWidth = "0.25"
      markerHeight = "0.2">
      <line
        x1 = "-0.25"
        y1 = "0"
        x2 = "0"
        y2 = "0" />
    </marker>
  </defs>
  <!-- B-axis -->
  <line
    x1 = "0"
    y1 = "-35"
    x2 = "21"
    y2 = "-35" />
  <text class="m"
    x = "21"
    y = "-35"
    font-size = "1"
    dx = "0.6em"
    dy = "0.3em"
    >B
  </text>
  <!-- Horizontal axis coarse ticks -->
  <polyline class="points"
    points = "0,-35 4,-35 8,-35 12,-35 16,-35 20,-35"
    marker-start = "url(#htickcoarse)"
    marker-mid   = "url(#htickcoarse)"
    marker-end   = "url(#htickcoarse)" />
  <text class="m"
    x = "0"
    y = "-35"
    font-size = "1"
    dy = "1.35em"
    >0
  </text>
  <text class="m"
    x = "4"
    y = "-35"
    font-size = "1"
    dy = "1.35em"
    >1
  </text>
  <text class="m"
    x = "8"
    y = "-35"
    font-size = "1"
    dy = "1.35em"
    >2
  </text>
  <text class="m"
    x = "12"
    y = "-35"
    font-size = "1"
    dy = "1.35em"
    >3
  </text>
  <text class="m"
    x = "16"
    y = "-35"
    font-size = "1"
    dy = "1.35em"
    >4
  </text>
  <text class="m"
    x = "20"
    y = "-35"
    font-size = "1"
    dy = "1.35em"
    >5
  </text>
  <!-- Horizontal axis fine ticks -->
  <polyline class="points"
    points = "0.8,-35 1.6,-35 2.4,-35 3.2,-35 4.8,-35 5.6,-35 6.4,-35 7.2,-35
      8.8,-35 9.6,-35 10.4,-35 11.2,-35 12.8,-35 13.6,-35 14.4,-35 15.2,-35
      16.8,-35 17.6,-35 18.4,-35 19.2,-35 20.8,-35"
    marker-start = "url(#htickfine)"
    marker-mid = "url(#htickfine)"
    marker-end = "url(#htickfine)" />
  <!-- phi-axis -->
  <line
    x1 = "0"
    y1 = "-35"
    x2 = "0"
    y2 = "-46.8" />
  <text class="m"
    x = "0"
    y = "-46.8"
    font-size = "1"
    dy = "-0.5em"
    >ϕ
  </text>
  <!-- Vertical axis coarse ticks -->
  <polyline class="points"
    points = "0,-35 0,-40 0,-45"
    marker-start = "url(#vtickcoarse)"
    marker-mid = "url(#vtickcoarse)"
    marker-end = "url(#vtickcoarse)" />
  <text class="m"
    x = "0"
    y = "-35"
    font-size = "1"
    dx = "-1.4em"
    dy = "0.3em"
    >35°
  </text>
  <text class="m"
    x = "0"
    y = "-40"
    font-size = "1"
    dx = "-1.4em"
    dy = "0.3em"
    >40°
  </text>
  <text class="m"
    x = "0"
    y = "-45"
    font-size = "1"
    dx = "-1.4em"
    dy = "0.3em"
    >45°
  </text>
  <!-- Vertical axis fine ticks -->
  <polyline class="points"
    points = "0,-36 0,-37 0,-38 0,-39 0,-41 0,-42 0,-43 0,-44 0,-46"
    marker-start = "url(#vtickfine)"
    marker-mid = "url(#vtickfine)"
    marker-end = "url(#vtickfine)" />
  <!-- numerical -->
  <!--
optimal_angle_export (0 : 0.2 : 2, "plot-b");
table = csvread ("optimal-angle-plot-b.csv");
table(:,1) *= 4;
table(:,2) *= -1;
csvwrite ("optimal-angle-plot-b.csv", table);
    -->
  <polyline
    points="0,-45
  0.4,-44.4287109375
  0.8,-43.912353515625
  1.2,-43.44268798828125
  1.6,-43.00872802734375
  2,-42.60772705078125
  2.4,-42.2369384765625
  2.8,-41.890869140625
  3.2,-41.56951904296875
  3.6,-41.2646484375
  4,-40.97900390625
  4.4,-40.70709228515625
  4.8,-40.44891357421875
  5.2,-40.20721435546875
  5.6,-39.9737548828125
  6,-39.7540283203125
  6.4,-39.54254150390625
  6.8,-39.33929443359375
  7.2,-39.144287109375
  7.6,-38.96026611328125
  8,-38.78173828125
  8.4,-38.60870361328125
  8.800000000000001,-38.441162109375
  9.199999999999999,-38.2818603515625
  9.6,-38.1280517578125
  10,-37.97698974609375
  10.4,-37.83416748046875
  10.8,-37.694091796875
  11.2,-37.5567626953125
  11.6,-37.4249267578125
  12,-37.298583984375
  12.4,-37.17498779296875
  12.8,-37.05413818359375
  13.2,-36.93603515625
  13.6,-36.82342529296875
  14,-36.7108154296875
  14.4,-36.60369873046875
  14.8,-36.49658203125
  15.2,-36.39495849609375
  15.6,-36.2933349609375
  16,-36.19720458984375
  16.40000000000001,-36.10107421875
  16.8,-36.00494384765625
  17.2,-35.914306640625
  17.6,-35.82366943359375
  18,-35.738525390625
  18.40000000000001,-35.650634765625
  18.8,-35.5682373046875
  19.2,-35.48583984375
  19.6,-35.4034423828125
  20,-35.32379150390625
  "
  />
  <text
    x = "10"
    y = "-37.97698974609375"
    font-size = "1"
    dx = "2.5em"
    dy = "-0.5em"
    >Numerical
  </text>
  <!-- asymptotic -->
  <!--
b_big_values = (0 : 0.05 : 2.05)';
table = [b_big_values, optimal_angle_asymptotic(b_big_values)];
table(:,1) *= 4;
table(:,2) *= -1;
csvwrite ("optimal-angle-asymptotic-plot-b-scaled.csv", table);
    -->
  <polyline
    points="0,-45
  0.2,-44.70730811994633
  0.4,-44.43106503807245
  0.6000000000000001,-44.17127075437838
  0.8,-43.92792526886412
  1,-43.70102858152967
  1.2,-43.49058069237503
  1.4,-43.29658160140019
  1.6,-43.11903130860515
  1.8,-42.95792981398992
  2,-42.81327711755451
  2.2,-42.68507321929889
  2.4,-42.57331811922309
  2.6,-42.47801181732709
  2.8,-42.39915431361089
  3,-42.3367456080745
  3.2,-42.29078570071793
  3.4,-42.26127459154115
  3.6,-42.24821228054418
  3.8,-42.25159876772702
  4,-42.27143405308966
  4.2,-42.30771813663211
  4.4,-42.36045101835437
  4.600000000000001,-42.42963269825643
  4.800000000000001,-42.51526317633832
  5,-42.61734245259998
  5.2,-42.73587052704146
  5.4,-42.87084739966276
  5.600000000000001,-43.02227307046386
  5.800000000000001,-43.19014753944476
  6,-43.37447080660547
  6.2,-43.57524287194598
  6.4,-43.79246373546631
  6.600000000000001,-44.02613339716643
  6.800000000000001,-44.27625185704637
  7,-44.54281911510611
  7.2,-44.82583517134567
  7.4,-45.12530002576502
  7.600000000000001,-45.44121367836419
  7.800000000000001,-45.77357612914315
  8,-46.12238737810192
  8.199999999999999,-46.4876474252405
  "
  />
  <text
    x = "8.4"
    y = "-46.8693562705589"
    font-size = "1"
    dx = "-3.5em"
    dy = "1em"
    >Asymptotic
  </text>
</svg>
</div>

<p>
  The true optimal launch angle is a decreasing function of <$>B</$>.
  Thus, very crudely, the asymptotic expansion becomes useless
  when it stops decreasing, which occurs at
</p>
<$$>
  B \approx \frac{-\phi_1}{2 \phi_2} = 0.9.
</$$>

<p>
  Finally, here is a plot of the optimal launch angle in terms of
  <$>\sqrt{B} = u / c</$>, the initial-to-terminal speed ratio:
</p>
<!--         Optimal launch angle plot (in terms of u / c)
  ***********************************************************************
  Constant    Description                           Value
  ***********************************************************************
    xleft       left x pos                            - 2.5
    xright      right x pos                            23
    w           total width                            25.5
    ytop        top y pos                             -48
    ybottom     bottom y pos                          -27
    h           total height                           21
  ***********************************************************************
  Horizontal scale is 5:1.
  -->
<div class="centred-svg">
<svg class="fit-width" width="480px" viewBox="-2.5 -48 25.5 21">
  <!-- u/c-axis -->
  <line
    x1 = "0"
    y1 = "-30"
    x2 = "20.5"
    y2 = "-30" />
  <text class="m"
    x = "20.5"
    y = "-30"
    font-size = "1"
    dx = "1.2em"
    dy = "0.3em"
    >u\,/\,c
  </text>
  <!-- Horizontal axis coarse ticks -->
  <polyline class="points"
    points = "0,-30 5,-30 10,-30 15,-30 20,-30"
    marker-start = "url(#htickcoarse)"
    marker-mid = "url(#htickcoarse)"
    marker-end = "url(#htickcoarse)" />
  <text class="m"
    x = "0"
    y = "-30"
    font-size = "1"
    dy = "1.35em"
    >0
  </text>
  <text class="m"
    x = "5"
    y = "-30"
    font-size = "1"
    dy = "1.35em"
    >1
  </text>
  <text class="m"
    x = "10"
    y = "-30"
    font-size = "1"
    dy = "1.35em"
    >2
  </text>
  <text class="m"
    x = "15"
    y = "-30"
    font-size = "1"
    dy = "1.35em"
    >3
  </text>
  <text class="m"
    x = "20"
    y = "-30"
    font-size = "1"
    dy = "1.35em"
    >4
  </text>
  <!-- Horizontal axis fine ticks -->
  <polyline class="points"
    points = "1,-30 2,-30 3,-30 4,-30 6,-30 7,-30 8,-30 9,-30
      11,-30 12,-30 13,-30 14,-30 16,-30 17,-30 18,-30 19,-30"
    marker-start = "url(#htickfine)"
    marker-mid = "url(#htickfine)"
    marker-end = "url(#htickfine)" />
  <!-- phi-axis -->
  <line
    x1 = "0"
    y1 = "-30"
    x2 = "0"
    y2 = "-46.8" />
  <text class="m"
    x = "0"
    y = "-46.8"
    font-size = "1"
    dy = "-0.5em"
    >ϕ
  </text>
  <!-- Vertical axis coarse ticks -->
  <polyline class="points"
    points = "0,-30 0,-35 0,-40 0,-45"
    marker-start = "url(#vtickcoarse)"
    marker-mid = "url(#vtickcoarse)"
    marker-end = "url(#vtickcoarse)" />
  <text class="m"
    x = "0"
    y = "-30"
    font-size = "1"
    dx = "-1.4em"
    dy = "0.3em"
    >30°
  </text>
  <text class="m"
    x = "0"
    y = "-35"
    font-size = "1"
    dx = "-1.4em"
    dy = "0.3em"
    >35°
  </text>
  <text class="m"
    x = "0"
    y = "-40"
    font-size = "1"
    dx = "-1.4em"
    dy = "0.3em"
    >40°
  </text>
  <text class="m"
    x = "0"
    y = "-45"
    font-size = "1"
    dx = "-1.4em"
    dy = "0.3em"
    >45°
  </text>
  <!-- Vertical axis fine ticks -->
  <polyline class="points"
    points = "0,-31 0,-32 0,-33 0,-34 0,-36 0,-37 0,-38 0,-39
      0,-41 0,-42 0,-43 0,-44 0,-46"
    marker-start = "url(#vtickfine)"
    marker-mid = "url(#vtickfine)"
    marker-end = "url(#vtickfine)" />
  <!-- numerical -->
  <!--
u_per_c_values = 0 : 0.1 : 4;
b_big_values = u_per_c_values .^ 2;
optimal_angle_export (b_big_values, "plot-u-per-c");
table = csvread ("optimal-angle-plot-u-per-c.csv");
table(:,1) = 5 * sqrt(table(:,1));
table(:,2) *= -1;
csvwrite ("optimal-angle-plot-u-per-c-scaled.csv", table);
    -->
  <polyline
    points="0,-45
  0.5,-44.9395751953125
  1,-44.7637939453125
  1.5,-44.483642578125
  2,-44.11285400390625
  2.5,-43.67340087890625
  3,-43.17901611328125
  3.5,-42.64617919921875
  4,-42.09686279296875
  4.5,-41.53656005859375
  5,-40.97900390625
  5.5,-40.4241943359375
  6,-39.8858642578125
  6.5,-39.3585205078125
  7,-38.85040283203125
  7.5,-38.36151123046875
  8,-37.891845703125
  8.500000000000002,-37.43865966796875
  9,-37.0074462890625
  9.5,-36.59271240234375
  10,-36.19720458984375
  10.5,-35.8154296875
  11,-35.452880859375
  11.5,-35.10406494140625
  12,-34.76898193359375
  12.5,-34.453125
  13,-34.1455078125
  13.5,-33.848876953125
  14,-33.56597900390625
  14.5,-33.2940673828125
  15,-33.0303955078125
  15.5,-32.78045654296875
  16,-32.5360107421875
  16.5,-32.30255126953125
  17,-32.0745849609375
  17.5,-31.8603515625
  18,-31.64886474609375
  18.5,-31.44287109375
  19,-31.24786376953125
  19.5,-31.058349609375
  20,-30.87432861328125
  "
  />
  <text
    x = "10"
    y = "-36.19720458984375"
    font-size = "1"
    dx = "2.5em"
    dy = "-0.5em"
    >Numerical
  </text>
  <!-- asymptotic -->
  <!--
u_per_c_values = (0 : 0.05 : 1.45)';
b_big_values = u_per_c_values .^ 2;
table = [u_per_c_values, optimal_angle_asymptotic(b_big_values)];
table(:,1) *= 5;
table(:,2) *= -1;
csvwrite ("optimal-angle-asymptotic-plot-u-per-c-scaled.csv", table);
    -->
  <polyline
    points="0,-45
  0.25,-44.98497474704055
  0.5,-44.94014572013488
  0.7500000000000001,-44.86625311520109
  1,-44.76453059210267
  1.25,-44.63670527464849
  1.5,-44.48499775059285
  1.75,-44.31212207163537
  2,-44.12128575342115
  2.25,-43.91618977554063
  2.5,-43.70102858152967
  2.75,-43.48049007886951
  3,-43.2597556389868
  3.25,-43.04450009725355
  3.5,-42.8408917529872
  3.75,-42.65559236945059
  4,-42.4957571738519
  4.25,-42.36903485734477
  4.5,-42.28356757502817
  4.75,-42.24799094594655
  5,-42.27143405308966
  5.25,-42.3635194433927
  5.5,-42.53436312773625
  5.750000000000001,-42.7945745809463
  6.000000000000001,-43.15525674179419
  6.25,-43.62800601299671
  6.5,-44.22491226121601
  6.75,-44.95855881705962
  7.000000000000001,-45.84202247508053
  7.25,-46.88887349377703
  "
  />
  <text
    x = "7.250000000000001"
    y = "-46.88887349377704"
    font-size = "1"
    dx = "-3.2em"
    dy = "1em"
    >Asymptotic
  </text>
</svg>
</div>

<@3> Code (GNU Octave) | code </@3>

<h4>Trajectories</h4>
<p>
  Trajectories are determined using numerical integration:
</p>
<``>
  ##  ----------------------------------------------------------------
  ##  [t_sol, z_sol, r_big] = trajectory (b_big, phi_pd)
  ##  ----------------------------------------------------------------
  ##  Determines the trajectory and range for projectile motion where drag is
  ##  proportional to the square of speed.
  ##  Input:
  ##    b_big  is the dimensionless group B == (b u^2) / (m g)
  ##    phi_pd is the launch angle phi divided by a degree, i.e. phi / degree
  ##  Output:
  ##    t_sol  is the column of solution t values
  ##    z_sol  is the matrix of solution (xdot, ydot, x, y) values
  ##    r_big  is the range R
  ##  Note that
  ##    b   is the drag coefficient
  ##    g   is the gravitational field strength
  ##    m   is the mass of the projectile
  ##    u   is the launch speed
  ##    phi is the launch angle.
  ##  The dimensionless group B == (b u^2) / (m g) is the initial drag-to-weight
  ##  ratio. After scaling by L == u^2 / g and T == u / g (which are the length
  ##  and time scales in the absence of drag), we get in scaled variables:
  ##    d/dt (xdot) ==    - B xdot sqrt (xdot^2 + ydot^2), xdot(0) == cos (phi)
  ##    d/dt (ydot) == -1 - B ydot sqrt (xdot^2 + ydot^2), xdot(0) == sin (phi)
  ##    d/dt (x)    ==        xdot                       ,    x(0) == 0
  ##    d/dt (y)    ==        ydot                       ,    y(0) == 0.
  ##  This is solved using ode45.

  function [t_sol, z_sol, r_big] = trajectory (b_big, phi_pd)
    
    ## Right hand side of system of ODEs in z == (xdot, ydot, x, y)
    fun = @(t, z) [
         - b_big * z(1) * sqrt(z(1)^2 + z(2)^2)
      -1 - b_big * z(2) * sqrt(z(1)^2 + z(2)^2)
                   z(1)
                   z(2)
    ];
    
    ## Initial values
    t_init = 0;
    z_init = [cosd(phi_pd), sind(phi_pd), 0, 0];
    
    ## Do not solve system of ODEs in the degenerate case phi == 0
    if (phi_pd == 0)
      t_sol = t_init;
      z_sol = z_init;
      r_big = z_init(3);
      return;
    endif
    
    ## Suppress termination warning
    warning ("off", "integrate_adaptive:unexpected_termination");
    
    ## Subfunction event_y_zero is defined below (for detecting y == 0 crossing)
    ## ----------------------------------------------------------------
    ## 1ST PASS: Determine flight time approximately
    ## ----------------------------------------------------------------
    
    ## Zero-drag flight time 2 sin (phi) is an upper bound
    t_end = 2 * sind (phi_pd);
    
    ## Time interval for ODE
    t_range = [t_init, t_end];
    
    ## ODE options structure (keep default time step)
    ode_struct = odeset ("Events", @event_y_zero);
    
    ## Solve system of ODEs
    [t_sol, z_sol] = ode45 (fun, t_range, z_init, ode_struct);
    
    ## Flight time
    t_end = t_sol(end);
    
    ## ----------------------------------------------------------------
    ## 2ND PASS: Use finer step size
    ## ----------------------------------------------------------------
    
    ## True flight time will probably be within 2/n of the rough flight time
    ## above, where n is the number of steps in the coarse solution above
    t_end = (1 + 2 / length (t_sol)) * t_end;
    
    ## Time interval for ODE
    t_range = [t_init, t_end];
    
    ## Maximum time step
    t_step = (t_end - t_init) / 100;
    
    ## ODE options structure
    ode_struct = odeset ("Events" , @event_y_zero, "MaxStep", t_step);
    
    ## Solve system of ODEs
    [t_sol, z_sol] = ode45 (fun, t_range, z_init, ode_struct);
    
    ## Range
    r_big = z_sol(end,3);
    
    ## Restore termination warning
    warning ("on", "integrate_adaptive:unexpected_termination");
    
  endfunction

  ## Event function which detects y == 0 crossing

  function [value, is_terminal, direction] = event_y_zero (t, z)
    
    value       = z(4);  # Component 4 of z == (xdot, ydot, x, y)
    is_terminal = true;  # Terminate integration when value == 0
    direction   = -1;    # and value is decreasing
    
  endfunction
</``>

<p>
  The trajectory shown at the top of this page corresponds to <$>B = 3</$>
  and a (non-optimal) launch angle of <$>\phi = \tan^{-1} (2) = 63.4 \degree</$>.
  The list of points (used in the SVG) was generated
  using the following script:
</p>
<``>
  b_big  = 3;
  phi_pd = atand (2);
  [~, z_sol, r_big] = trajectory (b_big, phi_pd);
  x_sol = z_sol(:, 3);
  y_sol = z_sol(:, 4);
  ## Scale to order 10 and negate y coordinates for SVG
  len   = 0.1 * r_big;
  x_sol =  x_sol / len;
  y_sol = -y_sol / len;
  csvwrite ("trajectory-plot.csv", [x_sol, y_sol]);
</``>

<h4>Optimal launch angle (numerical)</h4>

<p>
  First a range extractor:
</p>
<``>
  ##  ----------------------------------------------------------------
  ##  r_big = range (b_big, phi_pd)
  ##  ----------------------------------------------------------------
  ##  Dependencies: trajectory
  ##  ----------------------------------------------------------------
  ##  Determines the range for projectile motion where drag is proportional to
  ##  the square of speed.
  ##  Input:
  ##    b_big  is the dimensionless group B == (b u^2) / (m g)
  ##    phi_pd is the launch angle phi divided by a degree, i.e. phi / degree
  ##  Output:
  ##    r_big  is the range R
  ##  For more details see trajectory.m.

  function r_big = range (b_big, phi_pd)
    
    ## Range
    [~, ~, r_big] = trajectory (b_big, phi_pd);
    
  endfunction
</``>

<p>
  Then an implementation of the bisection algorithm for seeking maxima:
</p>
<``>
  ##  ----------------------------------------------------------------
  ##  x_opt = arg_max_bisection (fun, x_range, abs_tol)
  ##  ----------------------------------------------------------------
  ##  Determines maximising argument using the bisection algorithm.
  ##  Input:
  ##    fun     is the unimodal function to be maximised
  ##    x_range is the row of endpoints of the initial search interval in x
  ##    abs_tol is the absolute tolerance in x (default 1e-4 of the width of
  ##               x_range)
  ##  Output:
  ##    x_opt   is the optimal x
  ##  At each step, the function is evaluated at the five equally spaced points
  ##    x_a, x_b, x_c, x_d, x_e
  ##  to obtain function values
  ##    f_a, f_b, f_c, f_d, f_e
  ##  from which the width of the search interval is narrowed by half.

  function x_opt = arg_max_bisection (fun, x_range, abs_tol)
    
    ## Midpoint function
    mid = @(x_1, x_2) (x_1 + x_2) / 2;
    
    ## Initialise endpoints and midpoint of interval
    x_a = min (x_range);
    x_e = max (x_range);
    x_c = mid (x_a, x_e);
    
    ## Initialise function values at these points
    f_a = fun (x_a);
    f_e = fun (x_e);
    f_c = fun (x_c);
    
    ## Set default abs_tol if not supplied
    if (nargin < 3)
      abs_tol = (x_e - x_a) * 1e-4;
    endif
    
    ## Iterate
    while (abs (x_e - x_a) >= abs_tol)
      
      ## Quarter and three-quarter points of search interval
      x_b = mid (x_a, x_c);
      x_d = mid (x_c, x_e);
      
      ## Function values at these points
      f_b = fun (x_b);
      f_d = fun (x_d);
      
      ## Location (index) where function is maximised among the five points
      ##  ind     ==    1    2    3    4    5
      [~, ind] = max ([f_a, f_b, f_c, f_d, f_e]);
      
      ## Halve width of search interval
      if     (ind <= 2) # Maximum lies to the left half
        [x_c, x_e] = {x_b, x_c}{:};
        [f_c, f_e] = {f_b, f_c}{:};
      elseif (ind >= 4) # Maximum lies to the right half
        [x_a, x_c] = {x_c, x_d}{:};
        [f_a, f_c] = {f_c, f_d}{:};
      else              # Maximum lies in the central half
        [x_a, x_e] = {x_b, x_d}{:};
        [f_a, f_e] = {f_b, f_d}{:};
      endif
      
    endwhile
    
    ## Maximising argument
    x_opt = x_c;
    
  endfunction
</``>

<p>
  These are combined into a function which determines optimal launch angle
  for a given <$>B</$>:
</p>
<``>
  ##  ----------------------------------------------------------------
  ##  phi_pd_opt = optimal_angle (b_big, abs_tol)
  ##  ----------------------------------------------------------------
  ##  Dependencies: range, arg_max_bisection
  ##  ----------------------------------------------------------------
  ##  Determines the optimal launch angle (which maximises range) for projectile
  ##  motion where drag is proportional to the square of speed.
  ##  Input:
  ##    b_big      is the dimensionless group B == (b u^2) / (m g)
  ##    abs_tol    is the absolute tolerance in phi_pd
  ##  Output:
  ##    phi_pd_opt is the optimal launch angle phi divided by a degree,
  ##               i.e. phi_opt / degree (default 0.01)
  ##  For more details see trajectory.m.

  function phi_pd_opt = optimal_angle (b_big, abs_tol)
    
    ## Set default abs_tol if not supplied
    if (nargin < 2)
      abs_tol = 0.01;
    endif
    
    ## Range as a function of launch angle divided by a degree
    range_fun = @(phi_pd) range (b_big, phi_pd);
    
    ## Search interval
    phi_pd_range = [0, 90];
    
    ## Determine optimal angle using bisection
    phi_pd_opt = arg_max_bisection (range_fun, phi_pd_range, abs_tol);
    
  endfunction
</``>

<p>
  More convenient is a function which exports
  a table of values given several values of <$>B</$>:
</p>
<``>
  ##  ----------------------------------------------------------------
  ##  optimal_angle_export (b_big_values, name_suffix)
  ##  ----------------------------------------------------------------
  ##  Dependencies: optimal_angle
  ##  ----------------------------------------------------------------
  ##  Exports table of optimal launch angles per degree (which maximise range)
  ##  for projectile motion where drag is proportional to the square of speed.
  ##  Input:
  ##    b_big_values are the values of dimensionless group B == (b u^2) / (m g)
  ##    name_suffix  is the suffix for the filename of the exported table
  ##  For more details see trajectory.m.

  function optimal_angle_export (b_big_values, name_suffix)
    
    ## Timer on
    tic;
    
    ## Initialise table entries
    n_max = length (b_big_values);
    table = zeros (n_max, 2);
    
    ## Filename of table to be exported
    name = ["optimal-angle-", name_suffix, ".csv"];
    
    ## Initialise progress indicator
    handle = waitbar (0, ["Computing entries for ", name]);
    
    ## Compute table entries
    for n = 1 : n_max
      ## B
      b_big = b_big_values(n);
      table(n,1) = b_big;
      ## Optimal launch angle per degree
      phi_pd_opt = optimal_angle (b_big);
      table(n,2) = phi_pd_opt;
      ## Progress indicator
      waitbar (n / n_max, handle);
    endfor
    
    ## Close progress indicator
    close (handle);
    
    ## Export table
    csvwrite (name, table);
    
    ## Timer off
    toc;
    
  endfunction
</``>

<p>
  For example, the values in the table above were generated using
  the following script, which took 10~minutes to run in GNU Octave 4.4.0
  on a very old desktop with just 480~MB of RAM:
</p>
<``>
  optimal_angle_export (
    [ ...
      0 : 0.1 : 1, ...
      2 : 1   : 10, ...
      15, 20, 50, 100, 200, 500, ...
      10 .^ [3, 4, 6, 8]
    ],
    "table"
  );
</``>

<h4>Optimal launch angle (asymptotic)</h4>

<p>
  The following calulates the <$>B \ll 1</$>
  asymptotic launch angle using the <@> result | #result | Result </@> above:
</p>
<``>
  ##  ----------------------------------------------------------------
  ##  phi_pd_opt = optimal_angle_asymptotic (b_big)
  ##  ----------------------------------------------------------------
  ##  Determines the asymptotic optimal launch angle (which maximises range)
  ##  for projectile motion where drag is proportional to the square of speed,
  ##  but weak.
  ##  Input:
  ##    b_big      is the dimensionless group B == (b u^2) / (m g) << 1
  ##  Output:
  ##    phi_pd_opt is the optimal launch angle phi divided by a degree,
  ##               i.e. phi_opt / degree (default 0.01)
  ##  For more details see trajectory.m.

  function phi_pd_opt = optimal_angle_asymptotic (b_big)
    
    ## Construct polynomial coefficients to second order
    p = log ((1 + 1 / sqrt (2)) / (1 - 1 / sqrt (2)));
    phi_coeffs = zeros (1, 3);
    phi_coeffs(3) = pi / 4;
    phi_coeffs(2) = - 3/32 * sqrt (2) + 1/64 * p;
    phi_coeffs(1) = - 1393/3840 + 81/512 * sqrt (2) * p + 17/2048 * p^2;
    
    ## Evaluate
    phi_pd_opt = polyval (phi_coeffs, b_big) * 180 / pi;
    
  endfunction
</``>

<*c>
  Projectile motion: optimal launch angle for weak quadratic drag
  | weak-drag
  | Projectile motion: optimal launch angle for weak quadratic drag
</*c>

<*f> |
  The code above is released into the
  <@>
    public domain (CC0)
    | https://creativecommons.org/publicdomain/zero/1.0/
    | CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
  </@>.
</*f>